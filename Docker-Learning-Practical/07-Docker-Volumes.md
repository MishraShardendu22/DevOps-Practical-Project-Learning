# Docker Volumes

## Overview

Docker volumes are the preferred mechanism for persisting data generated by and used by Docker containers. They are completely managed by Docker and provide several advantages over bind mounts.

## Why Use Volumes?

- **Persistence**: Data survives container deletion
- **Sharing**: Multiple containers can use the same volume
- **Portability**: Works on all platforms (Linux, Windows, Mac)
- **Performance**: Better I/O performance than bind mounts
- **Backup**: Easier to back up and migrate
- **Docker Management**: Docker CLI commands to manage volumes

## Volume Commands

### Create Volume

```bash
# Create volume with default driver
docker volume create <volume-name>

# Create with specific driver
docker volume create --driver local <volume-name>

# Create with labels
docker volume create --label env=production data-vol
```

### List Volumes

```bash
# List all volumes
docker volume ls

# Filter volumes
docker volume ls --filter dangling=true
```

### Inspect Volume

```bash
# View detailed information
docker volume inspect <volume-name>

# Get mount point location
docker volume inspect --format '{{ .Mountpoint }}' <volume-name>
```

### Remove Volume

```bash
# Remove single volume
docker volume rm <volume-name>

# Remove all unused volumes
docker volume prune

# Force remove
docker volume rm -f <volume-name>
```

## Volume Types

### 1. Named Volumes (Recommended)

Managed by Docker with a specific name.

```bash
# Create named volume
docker volume create mydata

# Use in container
docker run -v mydata:/app/data nginx

# Multiple containers can share
docker run -v mydata:/data container1
docker run -v mydata:/data container2
```

**Advantages**:
- Easy to reference and manage
- Portable across systems
- Docker handles location
- Can be shared between containers

### 2. Anonymous Volumes

Created automatically without a name.

```bash
# Docker generates random name
docker run -v /app/data nginx
```

**Use Case**: Temporary data that doesn't need to persist

### 3. Bind Mounts

Mount specific host directory into container.

```bash
# Absolute path required
docker run -v /host/path:/container/path nginx

# Current directory (Linux/Mac)
docker run -v $(pwd):/app nginx

# Current directory (Windows PowerShell)
docker run -v ${PWD}:/app nginx
```

**Advantages**:
- Direct access to host files
- Useful for development
- Live code reloading

**Disadvantages**:
- Less portable
- Host-dependent paths
- Potential performance issues

## Volume vs Bind Mount

| Feature | Named Volume | Bind Mount |
|---------|--------------|------------|
| **Management** | Docker managed | User managed |
| **Location** | Docker controls | User specifies |
| **Portability** | High | Low |
| **Performance** | Optimized | Can be slower |
| **Use Case** | Production data | Development |
| **Backup** | Easy with Docker | Manual |

## Practical Examples

### Database Persistence

```bash
# MongoDB with volume
docker run -d \
  --name mongodb \
  -v mongo-data:/data/db \
  mongo:latest
```

### Development with Bind Mount

```bash
# Node.js development
docker run -d \
  --name dev-app \
  -v $(pwd):/app \
  -p 3000:3000 \
  node:18 \
  npm run dev
```

### Shared Volume Between Containers

```bash
# Create shared volume
docker volume create shared-logs

# App container writes logs
docker run -d --name app -v shared-logs:/var/log/app myapp

# Log processor reads logs
docker run -d --name logger -v shared-logs:/logs logprocessor
```

## Volume Backup and Restore

### Backup Volume

```bash
# Backup to tar file
docker run --rm \
  -v mydata:/data \
  -v $(pwd):/backup \
  ubuntu \
  tar czf /backup/mydata-backup.tar.gz /data
```

### Restore Volume

```bash
# Restore from tar file
docker run --rm \
  -v mydata:/data \
  -v $(pwd):/backup \
  ubuntu \
  tar xzf /backup/mydata-backup.tar.gz -C /
```

## Docker Compose with Volumes

```yaml
version: '3.9'

services:
  db:
    image: postgres:latest
    volumes:
      - db-data:/var/lib/postgresql/data
      
  app:
    image: myapp:latest
    volumes:
      - app-logs:/var/log/app
      - ./src:/app/src  # Bind mount for development

volumes:
  db-data:  # Named volume (managed by Docker)
  app-logs:
```

## Best Practices

### Production
- ✅ Use named volumes for data persistence
- ✅ Regular backups of critical volumes
- ✅ Monitor volume disk usage
- ✅ Use volume labels for organization
- ❌ Avoid bind mounts in production

### Development
- ✅ Use bind mounts for live code reloading
- ✅ Use `.dockerignore` to exclude unnecessary files
- ✅ Use read-only mounts when possible (`:ro`)
- ✅ Clean up unused volumes regularly

### Security
- Use read-only volumes when data shouldn't change:
  ```bash
  docker run -v mydata:/data:ro nginx
  ```
- Avoid mounting sensitive host directories
- Set appropriate permissions on bind mounts

### Performance
- Named volumes generally perform better than bind mounts
- On Mac/Windows, avoid bind mounts for large file trees
- Consider using volumes for database storage

## Troubleshooting

### Volume Not Found
```bash
# Check if volume exists
docker volume ls | grep myvolume

# Inspect volume
docker volume inspect myvolume
```

### Permission Issues
```bash
# Check volume ownership
docker run --rm -v mydata:/data alpine ls -la /data

# Fix permissions
docker run --rm -v mydata:/data alpine chown -R 1000:1000 /data
```

### Disk Space Issues
```bash
# Check volume size
docker system df -v

# Clean up unused volumes
docker volume prune
```

## Summary

- **Named volumes** for production data persistence
- **Bind mounts** for development and live reloading
- **Backup regularly** using tar archives
- **Clean up** unused volumes to save space
- **Monitor** volume usage with `docker system df`
